# ------------------------------------------------------
# Minimax with Alpha-Beta Pruning
# ------------------------------------------------------

def alpha_beta(node, depth, alpha, beta, maximizing_player, children_fn, value_fn):
    """
    node  : current game state
    depth : maximum search depth
    alpha : best value MAX can guarantee
    beta  : best value MIN can guarantee
    maximizing_player : True/False
    children_fn : function returning child states
    value_fn : heuristic evaluation of leaf states
    """

    # If depth is 0 â†’ evaluate
    if depth == 0:
        return value_fn(node), None

    # Get children
    children = children_fn(node)

    # Leaf node
    if not children:
        return value_fn(node), None

    best_move = None

    # --------------------------------------------------
    # MAXIMIZING PLAYER
    # --------------------------------------------------
    if maximizing_player:
        max_eval = float('-inf')

        for move, child in children:
            eval_val, _ = alpha_beta(child, depth - 1, alpha, beta,
                                     False, children_fn, value_fn)
            if eval_val > max_eval:
                max_eval = eval_val
                best_move = move

            alpha = max(alpha, eval_val)

            if beta <= alpha:
                break  # PRUNE

        return max_eval, best_move

    # --------------------------------------------------
    # MINIMIZING PLAYER
    # --------------------------------------------------
    else:
        min_eval = float('inf')

        for move, child in children:
            eval_val, _ = alpha_beta(child, depth - 1, alpha, beta,
                                     True, children_fn, value_fn)
            if eval_val < min_eval:
                min_eval = eval_val
                best_move = move

            beta = max(beta, eval_val)

            if beta <= alpha:
                break  # PRUNE

        return min_eval, best_move
